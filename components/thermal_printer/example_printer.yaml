# Enhanced Thermal Printer Configuration with DTR Handshaking
# Complete implementation with corrected UART pins

esphome:
  name: thermal_printer_dtr
  friendly_name: Enhanced Thermal Printer with DTR
  platform: ESP8266
  board: d1_mini

# WiFi Configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  ap:
    ssid: "ThermalPrinter-DTR"
    password: "thermalprint123"

captive_portal:

# Enhanced Logging for DTR debugging
logger:
  level: INFO
  logs:
    thermal_printer: DEBUG
    uart: INFO

ota:
  - platform: esphome
    password: !secret ota_password

# External Components
external_components:
  - source:
      type: local
      path: my_components

# CORRECTED UART Configuration - Using Hardware UART0
uart:
  id: thermal_uart
  tx_pin: GPIO1  # Hardware UART0 TX - ESP TX to printer RX
  rx_pin: GPIO3  # Hardware UART0 RX - ESP RX from printer TX
  baud_rate: 19200  # Recommended for DTR handshaking
  data_bits: 8
  parity: NONE
  stop_bits: 1

# Enhanced Home Assistant API with Queue System Services & DTR
api:
  encryption:
    key: !secret api_encryption_key
  actions:
    # ===== NEW: QUEUE-BASED SERVICES =====
    
    # Queue text printing (recommended for most use cases)
    - action: queue_print_text
      variables:
        message: string
        text_size: string
        alignment: string
        bold: bool
        underline: bool
        inverse: bool
        priority: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            uint8_t size = 2; // Default medium
            if (text_size == "S") size = 1;
            else if (text_size == "M") size = 2;
            else if (text_size == "L") size = 3;
            
            uint8_t align = 0; // Default left
            if (alignment == "C") align = 1;
            else if (alignment == "R") align = 2;
            
            uint8_t job_priority = priority > 0 ? priority : 0;
            
            auto result = printer->queue_text(message.c_str(), size, align, bold, job_priority);
            
            if (result == esphome::thermal_printer::PrintResult::SUCCESS) {
              ESP_LOGI("thermal_printer", "Text queued: '%s' (queue size: %d)", 
                       message.c_str(), printer->get_queue_length());
            } else {
              ESP_LOGW("thermal_printer", "Failed to queue text: result=%d", (int)result);
            }

    # Queue two-column printing
    - action: queue_two_column
      variables:
        left_text: string
        right_text: string
        fill_dots: bool
        text_size: string
        priority: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            char size_char = 'S';
            if (text_size == "M") size_char = 'M';
            else if (text_size == "L") size_char = 'L';
            
            uint8_t job_priority = priority > 0 ? priority : 0;
            
            auto result = printer->queue_two_column(
              left_text.c_str(), right_text.c_str(), fill_dots, size_char, job_priority);
            
            ESP_LOGI("thermal_printer", "Two-column queued: '%s' | '%s' (queue: %d)", 
                     left_text.c_str(), right_text.c_str(), printer->get_queue_length());

    # Queue barcode printing
    - action: queue_barcode
      variables:
        barcode_type: int
        barcode_data: string
        priority: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            uint8_t job_priority = priority > 0 ? priority : 0;
            
            auto result = printer->queue_barcode(barcode_type, barcode_data.c_str(), job_priority);
            ESP_LOGI("thermal_printer", "Barcode queued: type=%d, data='%s'", barcode_type, barcode_data.c_str());

    # Queue QR code printing
    - action: queue_qr_code
      variables:
        data: string
        size: int
        error_correction: int
        priority: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            uint8_t job_priority = priority > 0 ? priority : 0;
            
            auto result = printer->queue_qr_code(data.c_str(), size, error_correction, job_priority);
            ESP_LOGI("thermal_printer", "QR code queued: size=%d, data length=%d", size, strlen(data.c_str()));

    # Queue separator line
    - action: queue_separator
      variables:
        priority: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            uint8_t job_priority = priority > 0 ? priority : 0;
            auto result = printer->queue_separator(job_priority);

    # Queue paper feed
    - action: queue_feed_paper
      variables:
        lines: int
        priority: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            uint8_t job_priority = priority > 0 ? priority : 0;
            auto result = printer->queue_feed(lines, job_priority);

    # ===== EMERGENCY/IMMEDIATE SERVICES =====
    
    # Emergency print (bypasses queue for urgent messages)
    - action: print_text_immediate
      variables:
        message: string
        text_size: string
        alignment: string
        bold: bool
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            uint8_t size = 2;
            if (text_size == "S") size = 1;
            else if (text_size == "M") size = 2;
            else if (text_size == "L") size = 3;
            
            uint8_t align = 1; // Default center for emergencies
            if (alignment == "L") align = 0;
            else if (alignment == "R") align = 2;
            
            auto result = printer->print_immediate(message.c_str(), size, align, bold);
            
            if (result == esphome::thermal_printer::PrintResult::SUCCESS) {
              ESP_LOGI("thermal_printer", "Emergency print successful: '%s'", message.c_str());
            } else {
              ESP_LOGW("thermal_printer", "Emergency print failed: result=%d", (int)result);
            }

    # ===== QUEUE MANAGEMENT SERVICES =====
    
    # Clear print queue
    - action: clear_print_queue
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->clear_print_queue();
            ESP_LOGI("thermal_printer", "Print queue cleared");

    # Set print delay
    - action: set_print_delay
      variables:
        delay_ms: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->set_print_delay(delay_ms);
            ESP_LOGI("thermal_printer", "Print delay set to %dms", delay_ms);

    # Batch print multiple items
    - action: batch_print_text
      variables:
        items: string  # Items separated by "|"
        text_size: string
        priority: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            uint8_t size = 2;
            if (text_size == "S") size = 1;
            else if (text_size == "M") size = 2;
            else if (text_size == "L") size = 3;
            
            uint8_t job_priority = priority > 0 ? priority : 0;
            
            // Simple batch processing - parse items separated by "|"
            std::string items_str = items;
            size_t pos = 0;
            std::string delimiter = "|";
            int item_count = 0;
            
            while ((pos = items_str.find(delimiter)) != std::string::npos) {
              std::string item = items_str.substr(0, pos);
              if (!item.empty()) {
                auto result = printer->queue_text(item.c_str(), size, 0, false, job_priority);
                item_count++;
              }
              items_str.erase(0, pos + delimiter.length());
            }
            
            // Process last item
            if (!items_str.empty()) {
              auto result = printer->queue_text(items_str.c_str(), size, 0, false, job_priority);
              item_count++;
            }
            
            ESP_LOGI("thermal_printer", "Batch queued: %d items", item_count);

    # ===== ORIGINAL SERVICES (Now immediate for backward compatibility) =====
    
    # Original immediate services for compatibility
    - action: print_text
      variables:
        message: string
        text_size: string
        alignment: string
        bold: bool
        underline: bool
        inverse: bool
        rotation: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            // Use immediate printing for backward compatibility
            uint8_t size = 2;
            if (text_size == "S") size = 1;
            else if (text_size == "M") size = 2;
            else if (text_size == "L") size = 3;
            
            uint8_t align = 0;
            if (alignment == "C") align = 1;
            else if (alignment == "R") align = 2;
            
            auto result = printer->print_immediate(message.c_str(), size, align, bold);

    # Other original services remain for compatibility
    - action: wake_printer
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            ESP_LOGI("thermal_printer", "Waking printer");
            printer->wake();

    - action: sleep_printer
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            ESP_LOGI("thermal_printer", "Sleep printer");
            printer->sleep();

    - action: test_print
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            ESP_LOGI("thermal_printer", "Test print");
            printer->test();

    - action: reset_paper_usage
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->reset_paper_usage();

    - action: set_paper_roll_length
      variables:
        length_mm: float
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->set_paper_roll_length(length_mm);

# Enhanced Thermal Printer Configuration with Queue System
thermal_printer:
  id: my_thermal_printer
  uart_id: thermal_uart
  
  # Basic Configuration
  paper_roll_length: 30000
  line_height_calibration: 4.0
  enable_rotation: true
  enable_qr_codes: true
  startup_message: true
  
  # Heat Configuration (optimized for reliability)
  heat_dots: 7        # Conservative for reliability
  heat_time: 80       # Moderate heat time
  heat_interval: 2    # Fast heat interval
  
  # ===== NEW: QUEUE SYSTEM CONFIGURATION =====
  enable_queue_system: true    # Enable the queue system
  max_queue_size: 15          # Maximum 15 jobs in queue (increased with DTR)
  print_delay_ms: 300         # 300ms delay between jobs (reduced with DTR)
  auto_process_queue: true    # Automatically process queue in loop()
  
  # ===== DTR HANDSHAKING CONFIGURATION =====
  enable_dtr_handshaking: true  # Enable hardware flow control
  dtr_pin: GPIO4                # Boot/Flash pin - connect to printer DTR pin

# Enhanced sensors with Queue statistics
text_sensor:
  - platform: thermal_printer
    thermal_printer_id: my_thermal_printer
    name: "Paper Status"
    id: paper_status

  - platform: template
    name: "Printer Status Enhanced"
    id: printer_status_enhanced
    lambda: |-
      auto printer = id(my_thermal_printer);
      
      if (printer->is_printer_busy()) {
        return std::string("Printing");
      } else if (printer->get_queue_length() > 0) {
        return std::string("Queued (" + to_string(printer->get_queue_length()) + ")");
      } else if (printer->has_paper()) {
        return std::string("Ready");
      } else {
        return std::string("Paper Out");
      }
    update_interval: 5s

binary_sensor:
  - platform: thermal_printer
    thermal_printer_id: my_thermal_printer
    name: "Paper Loaded"
    id: paper_loaded

  - platform: template
    name: "Printer Busy"
    id: printer_busy
    lambda: |-
      return id(my_thermal_printer)->is_printer_busy();

  - platform: template
    name: "DTR Enabled"
    id: dtr_enabled
    device_class: connectivity
    lambda: |-
      return id(my_thermal_printer)->is_dtr_enabled();

sensor:
  - platform: uptime
    name: "Uptime"

  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  # ===== NEW: QUEUE SYSTEM SENSORS =====
  
  - platform: template
    name: "Print Queue Length"
    id: print_queue_length
    icon: mdi:printer-pos
    lambda: |-
      return id(my_thermal_printer)->get_queue_length();
    update_interval: 5s

  - platform: template
    name: "Total Jobs Processed"
    id: total_jobs_processed
    icon: mdi:counter
    state_class: total_increasing
    lambda: |-
      return id(my_thermal_printer)->get_total_jobs_processed();
    update_interval: 30s

  - platform: template
    name: "Jobs Dropped"
    id: jobs_dropped
    icon: mdi:alert-circle
    state_class: total_increasing
    lambda: |-
      return id(my_thermal_printer)->get_jobs_dropped();
    update_interval: 30s

  - platform: template
    name: "Average Job Time"
    id: average_job_time
    icon: mdi:timer
    unit_of_measurement: "ms"
    accuracy_decimals: 1
    lambda: |-
      return id(my_thermal_printer)->get_average_job_time();
    update_interval: 60s

  # ===== PAPER USAGE SENSORS =====
  
  - platform: template
    name: "Paper Usage (mm)"
    id: paper_usage_mm
    icon: mdi:ruler
    unit_of_measurement: "mm"
    accuracy_decimals: 1
    state_class: total_increasing
    lambda: |-
      return id(my_thermal_printer)->get_paper_usage_mm();
    update_interval: 30s

  - platform: template
    name: "Paper Usage (%)"
    id: paper_usage_percent
    icon: mdi:percent
    unit_of_measurement: "%"
    accuracy_decimals: 1
    lambda: |-
      return id(my_thermal_printer)->get_paper_usage_percent();
    update_interval: 30s

  - platform: template
    name: "Lines Printed"
    id: lines_printed
    icon: mdi:format-line-spacing
    state_class: total_increasing
    lambda: |-
      return id(my_thermal_printer)->get_lines_printed();
    update_interval: 30s

  - platform: template
    name: "Characters Printed"
    id: characters_printed
    icon: mdi:alphabetical
    state_class: total_increasing
    lambda: |-
      return id(my_thermal_printer)->get_characters_printed();
    update_interval: 30s

  # ===== DTR PERFORMANCE SENSORS =====
  
  - platform: template
    name: "DTR Timeouts"
    id: dtr_timeouts
    icon: mdi:timer-alert
    state_class: total_increasing
    lambda: |-
      return id(my_thermal_printer)->get_dtr_timeouts();
    update_interval: 60s

status_led:
  pin:
    number: GPIO2
    inverted: true

switch:
  - platform: template
    name: "Printer Wake"
    id: printer_wake_switch
    icon: mdi:power
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(my_thermal_printer)->wake();
    turn_off_action:
      - lambda: |-
          id(my_thermal_printer)->sleep();

  # ===== NEW: QUEUE CONTROL SWITCHES =====
  
  - platform: template
    name: "Auto Process Queue"
    id: auto_process_queue_switch
    icon: mdi:cog-clockwise
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_on_action:
      - lambda: |-
          id(my_thermal_printer)->enable_auto_queue_processing(true);
          ESP_LOGI("thermal_printer", "Auto queue processing enabled");
    turn_off_action:
      - lambda: |-
          id(my_thermal_printer)->enable_auto_queue_processing(false);
          ESP_LOGI("thermal_printer", "Auto queue processing disabled");

number:
  - platform: template
    name: "Line Spacing"
    id: line_spacing
    icon: mdi:format-line-spacing
    min_value: 24
    max_value: 64
    initial_value: 32
    step: 1
    mode: box
    optimistic: true
    set_action:
      - lambda: |-
          id(my_thermal_printer)->set_line_height(x);

  # ===== NEW: QUEUE CONFIGURATION CONTROLS =====
  
  - platform: template
    name: "Print Delay (seconds)"
    id: print_delay_setting
    icon: mdi:timer
    min_value: 1
    max_value: 10
    initial_value: 2
    step: 1
    mode: box
    optimistic: true
    set_action:
      - lambda: |-
          id(my_thermal_printer)->set_print_delay(x * 1000); // Convert to milliseconds
          ESP_LOGI("thermal_printer", "Print delay set to %.1f seconds", x);

  - platform: template
    name: "Max Queue Size"
    id: max_queue_size_setting
    icon: mdi:format-list-numbered
    min_value: 2
    max_value: 20
    initial_value: 10
    step: 1
    mode: box
    optimistic: true
    set_action:
      - lambda: |-
          id(my_thermal_printer)->set_max_queue_size(x);
          ESP_LOGI("thermal_printer", "Max queue size set to %.0f", x);

select:
  - platform: template
    name: "Default Text Size"
    id: default_text_size
    icon: mdi:format-size
    optimistic: true
    options:
      - "Small"
      - "Medium" 
      - "Large"
    initial_option: "Medium"

button:
  - platform: template
    name: "Print Test Page"
    id: test_page_button
    icon: mdi:printer-check
    on_press:
      - lambda: |-
          auto printer = id(my_thermal_printer);
          printer->test_page();

  - platform: template
    name: "Print Separator Line"
    id: separator_button
    icon: mdi:minus
    on_press:
      - lambda: |-
          auto printer = id(my_thermal_printer);
          auto result = printer->queue_separator(0);

  # ===== NEW: QUEUE MANAGEMENT BUTTONS =====
  
  - platform: template
    name: "Clear Print Queue"
    id: clear_queue_button
    icon: mdi:delete-sweep
    on_press:
      - lambda: |-
          auto printer = id(my_thermal_printer);
          printer->clear_print_queue();
          ESP_LOGI("thermal_printer", "Print queue cleared manually");

  - platform: template
    name: "Print Queue Status"
    id: queue_status_button
    icon: mdi:information
    on_press:
      - lambda: |-
          auto printer = id(my_thermal_printer);
          
          // Queue a status report
          std::string status_text = "=== QUEUE STATUS ===\n";
          status_text += "Queue Length: " + to_string(printer->get_queue_length()) + "\n";
          status_text += "Jobs Processed: " + to_string(printer->get_total_jobs_processed()) + "\n";
          status_text += "Jobs Dropped: " + to_string(printer->get_jobs_dropped()) + "\n";
          status_text += "Avg Job Time: " + to_string((int)printer->get_average_job_time()) + "ms\n";
          status_text += "Printer Busy: " + std::string(printer->is_printer_busy() ? "YES" : "NO") + "\n";
          status_text += "DTR Enabled: " + std::string(printer->is_dtr_enabled() ? "YES" : "NO") + "\n";
          status_text += "===================";
          
                      auto result = printer->queue_text(status_text.c_str(), 1, 0, false, 1); // Priority 1

  - platform: template
    name: "Emergency Test Print"
    id: emergency_test_button
    icon: mdi:alarm-light
    on_press:
      - lambda: |-
          auto printer = id(my_thermal_printer);
          
          // Use immediate emergency printing
          std::string emergency_msg = "ðŸš¨ EMERGENCY TEST\n" + to_string(millis()) + "ms";
          auto result = printer->print_immediate(emergency_msg.c_str(), 3, 1, true);
          
          if (result == esphome::thermal_printer::PrintResult::SUCCESS) {
            ESP_LOGI("thermal_printer", "Emergency test print successful");
          } else {
            ESP_LOGW("thermal_printer", "Emergency test print failed: %d", (int)result);
          }

  # ===== DTR TESTING BUTTONS =====
  
  - platform: template
    name: "Print DTR Stats"
    id: dtr_stats_button
    icon: mdi:chart-line
    on_press:
      - lambda: |-
          auto printer = id(my_thermal_printer);
          
          if (printer->is_dtr_enabled()) {
            std::string dtr_stats = "=== DTR STATISTICS ===\n";
            dtr_stats += "DTR Timeouts: " + to_string(printer->get_dtr_timeouts()) + "\n";
            dtr_stats += "DTR Status: ENABLED\n";
            dtr_stats += "=====================";
            
            auto result = printer->queue_text(dtr_stats.c_str(), 1, 0, false, 1);
          } else {
            auto result = printer->queue_text("DTR: DISABLED", 1, 1, false, 1);
          }

  - platform: template
    name: "Reset DTR Statistics"
    id: dtr_reset_button
    icon: mdi:counter
    on_press:
      - lambda: |-
          auto printer = id(my_thermal_printer);
          printer->reset_dtr_stats();
          ESP_LOGI("thermal_printer", "DTR statistics reset");

# Hardware Setup Instructions:
# 
# 1. UART CONNECTION (Hardware UART0):
#    - ESP8266 TX (GPIO1) -> Printer RX  [BEST PERFORMANCE]
#    - ESP8266 RX (GPIO3) -> Printer TX  [BEST PERFORMANCE]
#    - ESP8266 GND -> Printer GND
#    - Printer VCC -> 5V external power supply
#
# 2. DTR CONNECTION (OPTIONAL):
#    - Printer DTR pin -> ESP8266 GPIO0 (Boot/Flash pin)
#    - Requires opening printer case and soldering wire to DTR pad
#    - Some newer printers have DTR exposed on connector
#    - MUST be HIGH during boot (internal pullup helps)
#    - Disconnect DTR wire during firmware flashing if needed
#
# 3. QUEUE SYSTEM FEATURES:
#    - Automatic rate limiting (2 second delay between jobs)
#    - Up to 10 jobs can be queued
#    - Emergency printing bypasses queue
#    - Real-time queue monitoring
#    - Statistics tracking for performance analysis
#
# 4. USAGE EXAMPLES:
#
#    # Normal printing (queued)
#    service: esphome.thermal_printer_queue_print_text
#    data:
#      message: "Hello World!"
#      text_size: "M"
#      alignment: "C"
#      bold: true
#      priority: 0
#
#    # Emergency printing (immediate)
#    service: esphome.thermal_printer_print_text_immediate
#    data:
#      message: "ðŸš¨ URGENT MESSAGE"
#      text_size: "L"
#      alignment: "C"
#      bold: true
#
#    # Batch printing
#    service: esphome.thermal_printer_batch_print_text
#    data:
#      items: "Line 1|Line 2|Line 3"
#      text_size: "S"
#      priority: 0
