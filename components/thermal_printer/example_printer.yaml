# Minimal Working Enhanced Thermal Printer Configuration
# Phase 1 Implementation - Core Features Only

esphome:
  name: thermal_printer_enhanced
  friendly_name: Enhanced Thermal Printer
  platform: ESP8266
  board: d1_mini

# WiFi Configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  ap:
    ssid: "ThermalPrinter-Enhanced"
    password: "thermalprint123"

captive_portal:

# Logging
logger:
  level: INFO
  logs:
    thermal_printer: DEBUG

ota:
  - platform: esphome
    password: !secret ota_password

# External Components
external_components:
  - source:
      type: local
      path: my_components

# UART Configuration
uart:
  id: thermal_uart
  tx_pin: GPIO4  # D2 on D1 Mini
  rx_pin: GPIO0  # D3 on D1 Mini  
  baud_rate: 9600
  data_bits: 8
  parity: NONE
  stop_bits: 1

# Enhanced Home Assistant API with working Phase 1 services
api:
  encryption:
    key: !secret api_encryption_key
   
  # Ultra-simple working services for Phase 1
  actions:
    # Basic enhanced text printing with rotation
    - action: print_text
      variables:
        message: string
        text_size: string
        alignment: string
        bold: bool
        underline: bool
        inverse: bool
        rotation: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            if (text_size == "S") printer->set_text_size(1);
            else if (text_size == "M") printer->set_text_size(2);
            else if (text_size == "L") printer->set_text_size(3);
            
            if (alignment == "L") printer->justify('L');
            else if (alignment == "C") printer->justify('C');
            else if (alignment == "R") printer->justify('R');
            
            printer->bold_on(bold);
            printer->underline_on(underline);
            printer->inverse_on(inverse);
            
            if (rotation > 0) {
              printer->print_rotated_text(message.c_str(), rotation);
            } else {
              printer->print_text(message.c_str());
              printer->println();
            }
            
            printer->bold_off();
            printer->underline_off();
            printer->inverse_off();
            printer->justify('L');

    # NEW: Maximum impact rotated text - Large rotated letters vertically  
    - action: print_banner_text
      variables:
        message: string
        size: string  # S, M, L, XL for different impact levels
        spacing: int  # Lines between letters (default 2)
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            ESP_LOGI("thermal_printer", "Banner print: '%s', size: %s, spacing: %d", 
                     message.c_str(), size.c_str(), spacing);
            
            // Set text size based on parameter with XL support
            if (size == "XL" || size == "xl") {
              // XL: Use large size with double width and height
              printer->set_text_size(3);  // Maximum base size
              printer->double_width_on();  // Make it even wider
              printer->double_height_on(); // Make it even taller
              ESP_LOGI("thermal_printer", "Using XL size: 3 + double width/height");
            } else if (size == "L" || size == "l") {
              printer->set_text_size(3);  // Large
              ESP_LOGI("thermal_printer", "Using L size: 3");
            } else if (size == "M" || size == "m") {
              printer->set_text_size(2);  // Medium
              ESP_LOGI("thermal_printer", "Using M size: 2");
            } else {
              printer->set_text_size(1);  // Small
              ESP_LOGI("thermal_printer", "Using S size: 1");
            }
            
            // Center alignment and enable rotation
            printer->justify('C');
            
            // Test different rotation approaches for QR204 compatibility
            ESP_LOGI("thermal_printer", "Setting rotation...");
            printer->set_rotation(1);  // 90-degree rotation for each character
            
            const char* text = message.c_str();
            size_t text_len = strlen(text);
            int letter_spacing = spacing > 0 ? spacing : 2;
            
            ESP_LOGI("thermal_printer", "Printing %d characters with spacing %d", text_len, letter_spacing);
            
            // Print each character with proper bounds checking
            for (size_t i = 0; i < text_len; i++) {
              ESP_LOGD("thermal_printer", "Printing character %d: '%c'", i, text[i]);
              
              if (text[i] == ' ') {
                // Visual space indicator
                printer->print_text("•");
                printer->feed(letter_spacing);
              } else if (text[i] == '\n') {
                // Extra space for line breaks
                printer->feed(letter_spacing * 2);
              } else {
                // Print character - create proper null-terminated string
                char single_char[2];
                single_char[0] = text[i];
                single_char[1] = '\0';
                
                ESP_LOGD("thermal_printer", "Printing single char: '%s'", single_char);
                printer->print_text(single_char);
                printer->feed(letter_spacing);
              }
            }
            
            ESP_LOGI("thermal_printer", "Finished printing all characters, resetting...");
            
            // Reset everything carefully
            printer->set_rotation(0);  // CRITICAL: Reset rotation first
            printer->double_width_off();  // Reset width
            printer->double_height_off(); // Reset height  
            printer->justify('L');     // Reset alignment
            printer->set_text_size(2); // Reset to normal size
            printer->feed(3);          // Final spacing
            
    # Alternative banner method if ESC V rotation doesn't work on QR204
    - action: print_banner_alt
      variables:
        message: string
        size: string
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            ESP_LOGI("thermal_printer", "Alternative banner (no rotation): '%s'", message.c_str());
            
            // Try a different approach - use maximum size and spacing
            if (size == "XL" || size == "xl") {
              printer->set_text_size(3);
              printer->double_width_on();
              printer->double_height_on();
            } else if (size == "L" || size == "l") {
              printer->set_text_size(3);
            } else {
              printer->set_text_size(2);
            }
            
            printer->justify('C');
            
            const char* text = message.c_str();
            
            // Print each character on its own line with maximum impact
            for (size_t i = 0; i < strlen(text); i++) {
              if (text[i] == ' ') {
                printer->print_text("▪");  // Block for space
                printer->feed(3);
              } else if (text[i] != '\n') {
                char single_char[2] = {text[i], '\0'};
                printer->print_text(single_char);
                printer->feed(3);  // Extra spacing for drama
              }
            }
            
            // Reset
            printer->double_width_off();
            printer->double_height_off();
            printer->justify('L');
            printer->set_text_size(2);
            printer->feed(4);
            
            ESP_LOGI("thermal_printer", "Alternative banner complete");

    # Debug rotation command - test if QR204 supports ESC V
    - action: test_rotation
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            ESP_LOGI("thermal_printer", "Testing rotation support...");
            
            // Print normal
            printer->print_text("NORMAL");
            printer->feed(2);
            
            // Try rotation
            printer->set_rotation(1);
            printer->print_text("ROTATED?");
            printer->set_rotation(0);
            printer->feed(2);
            
            // Print normal again
            printer->print_text("NORMAL AGAIN");
            printer->feed(3);
            
            ESP_LOGI("thermal_printer", "Rotation test complete");

    # NEW: Label-style printing - Rotated characters printed vertically (BEST OF BOTH!)
    - action: print_label_text
      variables:
        message: string
        size: string    # S, M, L, XL for size control
        spacing: int    # Lines between characters (default 1)
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            ESP_LOGI("thermal_printer", "Label-style print: '%s', size: %s, spacing: %d", 
                     message.c_str(), size.c_str(), spacing);
            
            // Set text size based on parameter
            if (size == "XL" || size == "xl") {
              printer->set_text_size(3);
              printer->double_width_on();
              printer->double_height_on();
            } else if (size == "L" || size == "l") {
              printer->set_text_size(3);
            } else if (size == "M" || size == "m") {
              printer->set_text_size(2);
            } else {
              printer->set_text_size(1);
            }
            
            // Center alignment for best appearance
            printer->justify('C');
            
            // CRITICAL: Enable 90-degree rotation FIRST
            printer->set_rotation(1);
            
            const char* text = message.c_str();
            size_t text_len = strlen(text);
            int char_spacing = spacing > 0 ? spacing : 1;
            
            // Print each character rotated AND on separate lines
            for (size_t i = 0; i < text_len; i++) {
              if (text[i] == ' ') {
                // Visual space indicator
                printer->print_text("·");
                printer->feed(char_spacing);
              } else if (text[i] == '\n') {
                // Extra space for line breaks
                printer->feed(char_spacing * 2);
              } else {
                // Print rotated character on its own line
                char single_char[2] = {text[i], '\0'};
                printer->print_text(single_char);  // This should be rotated 90°
                printer->feed(char_spacing);       // Move to next line
              }
            }
            
            // Reset everything
            printer->set_rotation(0);       // Turn off rotation
            printer->double_width_off();    // Reset width
            printer->double_height_off();   // Reset height
            printer->justify('L');          // Reset alignment
            printer->set_text_size(2);      // Reset size
            printer->feed(2);               // Final spacing
            
            ESP_LOGI("thermal_printer", "Label-style print complete");

    # Keep the working individual services for comparison
    - action: print_rotated_text
      variables:
        message: string
        rotation: int
        size: string
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            // Set size if provided
            if (!size.empty()) {
              if (size == "L" || size == "l") {
                printer->set_text_size(3);
              } else if (size == "M" || size == "m") {
                printer->set_text_size(2);
              } else {
                printer->set_text_size(1);
              }
            }
            
            printer->print_rotated_text(message.c_str(), rotation);

    - action: print_vertical_text
      variables:
        message: string
        spacing: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->justify('C');
            
            const char* text = message.c_str();
            int char_spacing = spacing > 0 ? spacing : 1;
            
            for (size_t i = 0; i < strlen(text); i++) {
              if (text[i] == ' ') {
                printer->print_text("·");
                printer->feed(char_spacing);
              } else if (text[i] != '\n') {
                char single_char[2] = {text[i], '\0'};
                printer->print_text(single_char);
                printer->feed(char_spacing);
              } else {
                printer->feed(char_spacing * 2);
              }
            }
            
            printer->feed(2);
            printer->justify('L');

    # QR Code printing - NEW Phase 1 Feature  
    - action: print_qr_code
      variables:
        data: string
        size: int
        error_correction: int
        label: string
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            if (!label.empty()) {
              printer->justify('C');
              printer->set_text_size(1);
              printer->print_text(label.c_str());
              printer->feed(1);
            }
            printer->print_qr_code(data.c_str(), size, error_correction);

    # Enhanced two-column printing
    - action: print_two_column
      variables:
        left_text: string
        right_text: string
        fill_dots: bool
        text_size: string
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            char size_char = 'S';
            if (text_size == "M") size_char = 'M';
            else if (text_size == "L") size_char = 'L';
            printer->print_two_column(left_text.c_str(), right_text.c_str(), fill_dots, size_char);

    # Simple template printing - NEW Phase 1 Feature
    - action: print_receipt
      variables:
        business_name: string
        total: string
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->print_simple_receipt(business_name.c_str(), total.c_str());

    - action: print_shopping_list
      variables:
        items: string
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->print_shopping_list(items.c_str());

    # Safe printing without enum complications
    - action: safe_print_text
      variables:
        message: string
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            // Check paper before printing (simplified)
            if (printer->has_paper()) {
              printer->print_text(message.c_str());
              ESP_LOGI("thermal_printer", "Print successful");
            } else {
              ESP_LOGW("thermal_printer", "Cannot print - no paper");
            }

    # Paper management check - NEW Phase 1 Feature
    - action: check_can_print
      variables:
        estimated_lines: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            bool can_print = printer->can_print_job(estimated_lines);
            ESP_LOGI("thermal_printer", "Can print %d lines: %s", estimated_lines, can_print ? "YES" : "NO");

    # All original services preserved
    - action: print_barcode
      variables:
        barcode_type: int
        barcode_data: string
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->print_barcode(barcode_type, barcode_data.c_str());

    - action: feed_paper
      variables:
        lines: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->feed(lines);

    - action: wake_printer
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->wake();

    - action: sleep_printer
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->sleep();

    - action: test_print
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->test();

    - action: reset_paper_usage
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->reset_paper_usage();

    - action: set_paper_roll_length
      variables:
        length_mm: float
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->set_paper_roll_length(length_mm);

    - action: recover_printer
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->recover_from_error();

thermal_printer:
  id: my_thermal_printer
  uart_id: thermal_uart
  paper_roll_length: 30000
  line_height_calibration: 4.0
  enable_rotation: true
  enable_qr_codes: true
  startup_message: true

text_sensor:
  - platform: thermal_printer
    thermal_printer_id: my_thermal_printer
    name: "Paper Status"
    id: paper_status

  - platform: template
    name: "Printer Status"
    id: printer_status_simple
    lambda: |-
      auto printer = id(my_thermal_printer);
      if (printer->has_paper()) {
        return std::string("Ready - Paper OK");
      } else {
        return std::string("Paper Out");
      }
    update_interval: 30s

binary_sensor:
  - platform: thermal_printer
    thermal_printer_id: my_thermal_printer
    name: "Paper Loaded"
    id: paper_loaded

  - platform: template
    name: "Printer Online"
    id: printer_online
    device_class: connectivity
    lambda: |-
      return id(my_thermal_printer)->has_paper();

sensor:
  - platform: uptime
    name: "Uptime"

  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  - platform: template
    name: "Paper Usage (mm)"
    id: paper_usage_mm
    icon: mdi:ruler
    unit_of_measurement: "mm"
    accuracy_decimals: 1
    state_class: total_increasing
    lambda: |-
      return id(my_thermal_printer)->get_paper_usage_mm();
    update_interval: 30s

  - platform: template
    name: "Paper Usage (%)"
    id: paper_usage_percent
    icon: mdi:percent
    unit_of_measurement: "%"
    accuracy_decimals: 1
    lambda: |-
      return id(my_thermal_printer)->get_paper_usage_percent();
    update_interval: 30s

  - platform: template
    name: "Lines Printed"
    id: lines_printed
    icon: mdi:format-line-spacing
    state_class: total_increasing
    lambda: |-
      return id(my_thermal_printer)->get_lines_printed();
    update_interval: 30s

  - platform: template
    name: "Characters Printed"
    id: characters_printed
    icon: mdi:alphabetical
    state_class: total_increasing
    lambda: |-
      return id(my_thermal_printer)->get_characters_printed();
    update_interval: 30s

  - platform: template
    name: "Characters Per Minute"
    id: chars_per_minute
    icon: mdi:speedometer
    unit_of_measurement: "chars/min"
    accuracy_decimals: 1
    lambda: |-
      uint32_t uptime_minutes = millis() / 60000;
      if (uptime_minutes > 0) {
        return (float)id(my_thermal_printer)->get_characters_printed() / uptime_minutes;
      }
      return 0.0f;
    update_interval: 60s

status_led:
  pin:
    number: GPIO2
    inverted: true

switch:
  - platform: template
    name: "Printer Wake"
    id: printer_wake_switch
    icon: mdi:power
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(my_thermal_printer)->wake();
    turn_off_action:
      - lambda: |-
          id(my_thermal_printer)->sleep();

number:
  - platform: template
    name: "Line Spacing"
    id: line_spacing
    icon: mdi:format-line-spacing
    min_value: 24
    max_value: 64
    initial_value: 32
    step: 1
    mode: box
    optimistic: true
    set_action:
      - lambda: |-
          id(my_thermal_printer)->set_line_height(x);

select:
  - platform: template
    name: "Default Text Size"
    id: default_text_size
    icon: mdi:format-size
    optimistic: true
    options:
      - "Small"
      - "Medium" 
      - "Large"
    initial_option: "Medium"
    set_action:
      - lambda: |-
          auto printer = id(my_thermal_printer);
          if (x == "Small") {
            printer->set_text_size(1);
          } else if (x == "Medium") {
            printer->set_text_size(2);
          } else if (x == "Large") {
            printer->set_text_size(3);
          }

button:
  - platform: template
    name: "Print Test Page"
    id: test_page_button
    icon: mdi:printer-check
    on_press:
      - lambda: |-
          auto printer = id(my_thermal_printer);
          printer->test_page();

  - platform: template
    name: "Print Separator Line"
    id: separator_button
    icon: mdi:minus
    on_press:
      - lambda: |-
          auto printer = id(my_thermal_printer);
          printer->justify('C');
          printer->print_text("================================");
          printer->feed(1);
          printer->justify('L');

web_server:
  port: 80
  version: 2
