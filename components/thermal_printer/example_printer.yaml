# Minimal Working Enhanced Thermal Printer Configuration
# Phase 1 Implementation - Core Features Only

esphome:
  name: thermal_printer_enhanced
  friendly_name: Enhanced Thermal Printer
  platform: ESP8266
  board: d1_mini

# WiFi Configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  ap:
    ssid: "ThermalPrinter-Enhanced"
    password: "thermalprint123"

captive_portal:

# Logging
logger:
  level: INFO
  logs:
    thermal_printer: DEBUG

ota:
  - platform: esphome
    password: !secret ota_password

# External Components
external_components:
  - source:
      type: local
      path: my_components

# CORRECTED UART Configuration - Using Hardware UART0
uart:
  id: thermal_uart
  tx_pin: GPIO1  # Hardware UART0 TX - ESP TX to printer RX
  rx_pin: GPIO3  # Hardware UART0 RX - ESP RX from printer TX
  baud_rate: 19200  # Recommended for DTR handshaking
  data_bits: 8
  parity: NONE
  stop_bits: 1
  
# Enhanced Home Assistant API with working Phase 1 services
api:
  encryption:
    key: !secret api_encryption_key
  
  actions:
    # Enhanced text printing with DTR optimization
    - action: print_text
      variables:
        message: string
        text_size: string
        alignment: string
        bold: bool
        underline: bool
        inverse: bool
        rotation: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            // DTR handshaking will handle timing automatically
            if (text_size == "S") printer->set_text_size(1);
            else if (text_size == "M") printer->set_text_size(2);
            else if (text_size == "L") printer->set_text_size(3);
            
            if (alignment == "L") printer->justify('L');
            else if (alignment == "C") printer->justify('C');
            else if (alignment == "R") printer->justify('R');
            
            printer->bold_on(bold);
            printer->underline_on(underline);
            printer->inverse_on(inverse);
            
            if (rotation > 0) {
              printer->print_rotated_text(message.c_str(), rotation);
            } else {
              printer->print_text(message.c_str());
              printer->println();
            }
            
            printer->bold_off();
            printer->underline_off();
            printer->inverse_off();
            printer->justify('L');

    # Fast rotated text - optimized for DTR handshaking
    - action: print_rotated_text
      variables:
        message: string
        rotation: int
        size: string
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            ESP_LOGI("thermal_printer", "DTR-optimized rotation print: '%s'", message.c_str());
            
            // Set size if provided (but prefer small for rotation reliability)
            if (!size.empty()) {
              if (size == "S" || size == "s") {
                printer->set_text_size(1);
              } else {
                ESP_LOGW("thermal_printer", "Using small size for rotation stability");
                printer->set_text_size(1);
              }
            }
            
            printer->print_rotated_text(message.c_str(), rotation);

    # DTR-optimized QR codes
    - action: print_qr_code
      variables:
        data: string
        size: int
        error_correction: int
        label: string
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            if (!label.empty()) {
              printer->justify('C');
              printer->set_text_size(1);
              printer->print_text(label.c_str());
              printer->feed(1);
            }
            
            ESP_LOGI("thermal_printer", "DTR-optimized QR code: size=%d, length=%d", size, strlen(data.c_str()));
            printer->print_qr_code(data.c_str(), size, error_correction);

    # Enhanced two-column printing with DTR flow control
    - action: print_two_column
      variables:
        left_text: string
        right_text: string
        fill_dots: bool
        text_size: string
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            char size_char = 'S';
            if (text_size == "M") size_char = 'M';
            else if (text_size == "L") size_char = 'L';
            
            ESP_LOGI("thermal_printer", "DTR two-column: '%s' | '%s'", left_text.c_str(), right_text.c_str());
            printer->print_two_column(left_text.c_str(), right_text.c_str(), fill_dots, size_char);

    # DTR Statistics and debugging
    - action: print_dtr_stats
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            if (printer->is_dtr_enabled()) {
              printer->set_text_size(1);
              printer->justify('L');
              printer->print_text("=== DTR STATISTICS ===");
              printer->feed(1);
              
              char stats_line[64];
              snprintf(stats_line, sizeof(stats_line), "DTR Timeouts: %u", printer->get_dtr_timeouts());
              printer->print_text(stats_line);
              printer->feed(1);
              
              printer->print_text("DTR: ENABLED");
              printer->feed(1);
              
              printer->print_text("====================");
              printer->feed(2);
              
              ESP_LOGI("thermal_printer", "DTR Stats - Timeouts: %u", printer->get_dtr_timeouts());
            } else {
              printer->print_text("DTR: DISABLED");
              printer->feed(2);
            }

    # Reset DTR statistics
    - action: reset_dtr_stats
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->reset_dtr_stats();
            ESP_LOGI("thermal_printer", "DTR statistics reset");

    # Test DTR responsiveness
    - action: test_dtr_performance
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            
            if (!printer->is_dtr_enabled()) {
              ESP_LOGW("thermal_printer", "DTR not enabled - cannot test performance");
              return;
            }
            
            ESP_LOGI("thermal_printer", "Testing DTR performance...");
            
            // Print test pattern to stress DTR handshaking
            printer->set_text_size(1);
            printer->justify('L');
            printer->print_text("DTR Performance Test");
            printer->feed(1);
            
            uint32_t start_time = millis();
            
            // Rapid character sequence
            for (int i = 0; i < 50; i++) {
              char test_char[2] = {'0' + (i % 10), '\0'};
              printer->print_text(test_char);
            }
            printer->feed(1);
            
            uint32_t test_duration = millis() - start_time;
            
            char result_line[64];
            snprintf(result_line, sizeof(result_line), "Test Duration: %ums", test_duration);
            printer->print_text(result_line);
            printer->feed(1);
            
            snprintf(result_line, sizeof(result_line), "DTR Timeouts: %u", printer->get_dtr_timeouts());
            printer->print_text(result_line);
            printer->feed(3);
            
            ESP_LOGI("thermal_printer", "DTR performance test complete: %ums, timeouts: %u", 
                     test_duration, printer->get_dtr_timeouts());

    # All original services preserved with DTR optimization
    - action: print_barcode
      variables:
        barcode_type: int
        barcode_data: string
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            ESP_LOGI("thermal_printer", "DTR-optimized barcode: type=%d", barcode_type);
            printer->print_barcode(barcode_type, barcode_data.c_str());

    - action: feed_paper
      variables:
        lines: int
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            ESP_LOGD("thermal_printer", "DTR feed: %d lines", lines);
            printer->feed(lines);

    - action: wake_printer
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            ESP_LOGI("thermal_printer", "Waking printer (DTR-aware)");
            printer->wake();

    - action: sleep_printer
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            ESP_LOGI("thermal_printer", "Sleep printer (DTR-aware)");
            printer->sleep();

    - action: test_print
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            ESP_LOGI("thermal_printer", "Test print (DTR-optimized)");
            printer->test();

    - action: reset_paper_usage
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->reset_paper_usage();

    - action: set_paper_roll_length
      variables:
        length_mm: float
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            printer->set_paper_roll_length(length_mm);

    - action: recover_printer
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            ESP_LOGI("thermal_printer", "Printer recovery (DTR-aware)");
            printer->recover_from_error();

    # Table printing support
    - action: print_table_row
      variables:
        col1: string
        col2: string
        col3: string
        header: bool
      then:
        - lambda: |-
            auto printer = id(my_thermal_printer);
            if (header) {
              printer->bold_on();
            }
            printer->print_table_row(col1.c_str(), col2.c_str(), col3.c_str());
            if (header) {
              printer->bold_off();
            }

# Enhanced Thermal Printer Configuration with DTR
thermal_printer:
  id: my_thermal_printer
  uart_id: thermal_uart
  
  # Basic Configuration
  paper_roll_length: 30000
  line_height_calibration: 4.0
  enable_rotation: true
  enable_qr_codes: true
  startup_message: true
  
  # Heat Configuration (optimized for DTR)
  heat_dots: 7        # Conservative for reliability
  heat_time: 80       # Moderate heat time
  heat_interval: 2    # Fast heat interval (DTR will handle timing)
  
  # ===== DTR HANDSHAKING CONFIGURATION =====
  enable_dtr_handshaking: true  # Enable hardware flow control
  dtr_pin: GPIO0                # Boot/Flash pin - connect to printer DTR pin
  
  # Alternative DTR pin options (if GPIO0 causes boot issues):
  # dtr_pin: GPIO5   # D1 on D1 Mini (recommended alternative)
  # dtr_pin: GPIO12  # D6 on D1 Mini
  # dtr_pin: GPIO13  # D7 on D1 Mini  
  # dtr_pin: GPIO14  # D5 on D1 Mini
  # dtr_pin: GPIO2   # Built-in LED pin (disable status_led if used)

# Enhanced sensors with DTR statistics
text_sensor:
  - platform: thermal_printer
    thermal_printer_id: my_thermal_printer
    name: "Paper Status"
    id: paper_status

  - platform: template
    name: "Printer Status"
    id: printer_status_enhanced
    lambda: |-
      auto printer = id(my_thermal_printer);
      if (printer->is_dtr_enabled()) {
        if (printer->has_paper()) {
          return std::string("Ready - DTR Enabled");
        } else {
          return std::string("Paper Out - DTR Enabled");
        }
      } else {
        if (printer->has_paper()) {
          return std::string("Ready - No DTR");
        } else {
          return std::string("Paper Out - No DTR");
        }
      }
    update_interval: 30s

binary_sensor:
  - platform: thermal_printer
    thermal_printer_id: my_thermal_printer
    name: "Paper Loaded"
    id: paper_loaded

  - platform: template
    name: "DTR Handshaking"
    id: dtr_enabled
    device_class: connectivity
    lambda: |-
      return id(my_thermal_printer)->is_dtr_enabled();

sensor:
  - platform: uptime
    name: "Uptime"

  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  - platform: template
    name: "Paper Usage (mm)"
    id: paper_usage_mm
    icon: mdi:ruler
    unit_of_measurement: "mm"
    accuracy_decimals: 1
    state_class: total_increasing
    lambda: |-
      return id(my_thermal_printer)->get_paper_usage_mm();
    update_interval: 30s

  - platform: template
    name: "Paper Usage (%)"
    id: paper_usage_percent
    icon: mdi:percent
    unit_of_measurement: "%"
    accuracy_decimals: 1
    lambda: |-
      return id(my_thermal_printer)->get_paper_usage_percent();
    update_interval: 30s

  - platform: template
    name: "Lines Printed"
    id: lines_printed
    icon: mdi:format-line-spacing
    state_class: total_increasing
    lambda: |-
      return id(my_thermal_printer)->get_lines_printed();
    update_interval: 30s

  - platform: template
    name: "Characters Printed"
    id: characters_printed
    icon: mdi:alphabetical
    state_class: total_increasing
    lambda: |-
      return id(my_thermal_printer)->get_characters_printed();
    update_interval: 30s

  # NEW: DTR Performance Sensors
  - platform: template
    name: "DTR Timeouts"
    id: dtr_timeouts
    icon: mdi:timer-alert
    state_class: total_increasing
    lambda: |-
      return id(my_thermal_printer)->get_dtr_timeouts();
    update_interval: 60s

  - platform: template
    name: "Print Success Rate"
    id: print_success_rate
    icon: mdi:percent
    unit_of_measurement: "%"
    accuracy_decimals: 1
    lambda: |-
      auto printer = id(my_thermal_printer);
      uint32_t total_ops = printer->get_lines_printed();
      uint32_t timeouts = printer->get_dtr_timeouts();
      
      if (total_ops == 0) return 100.0f;
      
      float success_rate = ((float)(total_ops - timeouts) / total_ops) * 100.0f;
      return success_rate > 0.0f ? success_rate : 0.0f;
    update_interval: 60s

status_led:
  pin:
    number: GPIO2
    inverted: true

switch:
  - platform: template
    name: "Printer Wake"
    id: printer_wake_switch
    icon: mdi:power
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(my_thermal_printer)->wake();
    turn_off_action:
      - lambda: |-
          id(my_thermal_printer)->sleep();

  # NEW: DTR Control Switch
  - platform: template
    name: "DTR Debug Mode"
    id: dtr_debug_switch
    icon: mdi:bug
    optimistic: true
    turn_on_action:
      - logger.log:
          level: DEBUG
          tag: "thermal_printer"
          format: "DTR Debug mode enabled"
    turn_off_action:
      - logger.log:
          level: INFO
          tag: "thermal_printer" 
          format: "DTR Debug mode disabled"

number:
  - platform: template
    name: "Line Spacing"
    id: line_spacing
    icon: mdi:format-line-spacing
    min_value: 24
    max_value: 64
    initial_value: 32
    step: 1
    mode: box
    optimistic: true
    set_action:
      - lambda: |-
          id(my_thermal_printer)->set_line_height(x);

select:
  - platform: template
    name: "Default Text Size"
    id: default_text_size
    icon: mdi:format-size
    optimistic: true
    options:
      - "Small"
      - "Medium" 
      - "Large"
    initial_option: "Medium"
    set_action:
      - lambda: |-
          auto printer = id(my_thermal_printer);
          if (x == "Small") {
            printer->set_text_size(1);
          } else if (x == "Medium") {
            printer->set_text_size(2);
          } else if (x == "Large") {
            printer->set_text_size(3);
          }

button:
  - platform: template
    name: "Print Test Page"
    id: test_page_button
    icon: mdi:printer-check
    on_press:
      - lambda: |-
          auto printer = id(my_thermal_printer);
          printer->test_page();

  - platform: template
    name: "Print Separator Line"
    id: separator_button
    icon: mdi:minus
    on_press:
      - lambda: |-
          auto printer = id(my_thermal_printer);
          printer->justify('C');
          printer->print_text("================================");
          printer->feed(1);
          printer->justify('L');

  # NEW: DTR Testing Buttons
  - platform: template
    name: "Print DTR Stats"
    id: dtr_stats_button
    icon: mdi:chart-line
    on_press:
      - esphome.thermal_printer_dtr_print_dtr_stats:

  - platform: template
    name: "Test DTR Performance"
    id: dtr_performance_button
    icon: mdi:speedometer
    on_press:
      - esphome.thermal_printer_dtr_test_dtr_performance:

  - platform: template
    name: "Reset DTR Statistics"
    id: dtr_reset_button
    icon: mdi:counter
    on_press:
      - esphome.thermal_printer_dtr_reset_dtr_stats:

web_server:
  port: 80
  version: 2

# Hardware Setup Instructions - UPDATED for your pin choice:
# 
# 1. UART CONNECTION (Hardware UART0):
#    - ESP8266 TX (GPIO1) -> Printer RX  [BEST PERFORMANCE]
#    - ESP8266 RX (GPIO3) -> Printer TX  [BEST PERFORMANCE]
#    - ESP8266 GND -> Printer GND
#    - Printer VCC -> 5V external power supply
#
# 2. DTR CONNECTION:
#    - Printer DTR pin -> ESP8266 GPIO0 (Boot/Flash pin)
#    - Requires opening printer case and soldering wire to DTR pad
#    - Some newer printers have DTR exposed on connector
# 
# 3. IMPORTANT GPIO0 (Boot Pin) CONSIDERATIONS:
#    - MUST be HIGH during boot (internal pullup helps)
#    - Disconnect DTR wire during firmware flashing
#    - Pull DTR high with 10kΩ resistor if experiencing boot issues
#    - Works perfectly as DTR input during normal operation
#
# 4. VERIFICATION:
#    - "DTR Handshaking" sensor should show "on" 
#    - "DTR Timeouts" sensor should stay at 0 or very low
#    - Test with "Test DTR Performance" button
#
# 5. TROUBLESHOOTING:
#    - Boot issues: Add 10kΩ pullup resistor GPIO0 to 3.3V
#    - Flash issues: Disconnect DTR wire during programming
#    - High DTR timeouts: check wiring, printer firmware compatibility
#    - Missing charact
